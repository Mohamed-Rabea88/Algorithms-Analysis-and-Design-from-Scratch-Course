{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "fba7c058",
   "metadata": {},
   "source": [
    "## Circle Area"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "9efaeca1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "what the area radius? 2\n",
      "circle area = 12.566370614359172\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "def circle_area():\n",
    "    radius=float(input('what the area radius? '))\n",
    "    # Area = πr²\n",
    "    area=(np.pi) * (radius**2)  \n",
    "    print(f'circle area = {area}')\n",
    "    \n",
    "circle_area()                    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e09ad085",
   "metadata": {},
   "source": [
    "## Parallelogram Area"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "4ced6d61",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "what is the base? 2\n",
      "what is the height? 8\n",
      "parallelogram area = 16.0\n"
     ]
    }
   ],
   "source": [
    "def parallelogram_area():\n",
    "    base = float(input('what is the base? '))\n",
    "    height=float(input('what is the height? '))\n",
    "    # A = bh\n",
    "    area = base * height\n",
    "    print(f'parallelogram area = {area}')\n",
    "    \n",
    "parallelogram_area()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f9f9312",
   "metadata": {},
   "source": [
    "## Trapezoid Area"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "fadf4b34",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "what is the short base? 3\n",
      "what is the long base? 7\n",
      "what is the height? 5\n",
      "trapezoid area = 25.0\n"
     ]
    }
   ],
   "source": [
    "def trapezoid_area():\n",
    "    short_base=float(input('what is the short base? '))\n",
    "    long_base=float(input('what is the long base? '))\n",
    "    height=float(input('what is the height? '))\n",
    "    # A = (a+b)/2 * h\n",
    "    area= (short_base+long_base)/2 * height\n",
    "    print(f'trapezoid area = {area}')\n",
    "\n",
    "trapezoid_area()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b60331da",
   "metadata": {},
   "source": [
    "## Standard deviation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "44e97a20",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total number of array elements: 8\n",
      "array element 0: 10\n",
      "array element 1: 12\n",
      "array element 2: 23\n",
      "array element 3: 23\n",
      "array element 4: 16\n",
      "array element 5: 23\n",
      "array element 6: 21\n",
      "array element 7: 16\n",
      "standard deviation = 4.898979485566356\n"
     ]
    }
   ],
   "source": [
    "def standard_deviation():\n",
    "    array_length=int(input('total number of array elements: '))\n",
    "    array=[]\n",
    "    for i in range(array_length):\n",
    "        array.append(float(input(f'array element {i}: ')))\n",
    "    \n",
    "    # σ = squre_root(∑( X − μ )²/ n)\n",
    "    mean=sum(array)/array_length\n",
    "    squared_difference=0\n",
    "    for i in array:\n",
    "        squared_difference +=(i-mean)**2\n",
    "    standard_deviation = np.sqrt(squared_difference/array_length)\n",
    "    print(f'standard deviation = {standard_deviation}')\n",
    "    \n",
    "standard_deviation()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37ab23a7",
   "metadata": {},
   "source": [
    "## Correlation Coefficient"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "2a5d46a7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sample size: 5\n",
      "first array element 0: 2\n",
      "first array element 1: 4\n",
      "first array element 2: 6\n",
      "first array element 3: 1\n",
      "first array element 4: 4\n",
      "second array element 0: 11\n",
      "second array element 1: 6\n",
      "second array element 2: 17\n",
      "second array element 3: 3\n",
      "second array element 4: 4\n",
      "correlation coefficient = 0.6097367084753432\n"
     ]
    }
   ],
   "source": [
    "def correlation_coefficient():\n",
    "    array_length=int(input('sample size: '))\n",
    "    first_array=[]\n",
    "    second_array=[]\n",
    "    for i in range(array_length):\n",
    "        first_array.append(float(input(f'first array element {i}: ')))\n",
    "    for j in range(array_length):\n",
    "        second_array.append(float(input(f'second array element {j}: ')))\n",
    "        \n",
    "    # r= (∑(x − X)(y-Y))/square_root(∑(x − X)² ∑( y − Y)²)\n",
    "    first_array_mean=sum(first_array)/array_length\n",
    "    second_array_mean=sum(second_array)/array_length\n",
    "    x_y_difference=0\n",
    "    x_squared_difference=0\n",
    "    y_squared_difference=0\n",
    "    for i,j in zip(first_array,second_array):\n",
    "        x_y_difference += (i-first_array_mean)*(j-second_array_mean)\n",
    "        x_squared_difference += (i-first_array_mean)**2\n",
    "        y_squared_difference += (j-second_array_mean)**2\n",
    "    correlation_coefficient = (x_y_difference)/np.sqrt(x_squared_difference*y_squared_difference)\n",
    "    \n",
    "    print(f'correlation coefficient = {correlation_coefficient}')\n",
    "    \n",
    "correlation_coefficient()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ed1e1a6",
   "metadata": {},
   "source": [
    "## Insertion Sort"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "35547ac0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total number of array elements: 9\n",
      "array element 0: 16\n",
      "array element 1: 27\n",
      "array element 2: 19\n",
      "array element 3: 2\n",
      "array element 4: 30\n",
      "array element 5: 10\n",
      "array element 6: 10\n",
      "array element 7: 27\n",
      "array element 8: 55\n",
      "sorted array is: [2, 10, 10, 16, 19, 27, 27, 30, 55]\n"
     ]
    }
   ],
   "source": [
    "def insertion_sort():\n",
    "    array_length=int(input('total number of array elements: '))\n",
    "    array=[]\n",
    "    for i in range(array_length):\n",
    "        array.append(int(input(f'array element {i}: ')))\n",
    "        \n",
    "    # loop on every element in the array starting from second element\n",
    "    # store the elemnt in temporary variaable\n",
    "    for i in range(1,array_length):\n",
    "        k=array[i]\n",
    "        # loop on all previous elemnts\n",
    "        for j in range(i-1,-1,-1):\n",
    "            # check if previus is bigger\n",
    "            if array[j] > k:\n",
    "                array[j+1]=array[j]\n",
    "            else:\n",
    "                break\n",
    "            array[j]=k\n",
    "            \n",
    "    print(f'sorted array is: {array}')\n",
    "\n",
    "insertion_sort()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ea5ab634",
   "metadata": {},
   "source": [
    "## Merge Sort"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "a65d1830",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'sorted array = [1, 2, 5, 7, 9, 12]'"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def merge_sort(array):\n",
    "    \n",
    "    # recursion\n",
    "    # check baase condition\n",
    "    if len(array) > 1:\n",
    "        # divide and conquer\n",
    "        mid = len(array)//2\n",
    "        left_array=array[:mid]\n",
    "        right_array=array[mid:]\n",
    "        merge_sort(left_array)\n",
    "        merge_sort(right_array)\n",
    "        # temporary variables for looping\n",
    "        i=j=k=0\n",
    "        while i < len(left_array) and j < len(right_array):\n",
    "            if left_array[i] < right_array[j]:\n",
    "                array[k] = left_array[i]\n",
    "                i+=1\n",
    "                k+=1\n",
    "            else:\n",
    "                array[k] = right_array[j]\n",
    "                j+=1\n",
    "                k+=1\n",
    "        while i < len(left_array):\n",
    "            array[k]=left_array[i]\n",
    "            i+=1\n",
    "            k+=1\n",
    "        while j < len(right_array):\n",
    "            array[k]=right_array[j]\n",
    "            j+=1\n",
    "            k+=1\n",
    "            \n",
    "    return f'sorted array = {array}'\n",
    "\n",
    "merge_sort([2,5,1,9,7,12])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a2a840b8",
   "metadata": {},
   "source": [
    "## Binary Search"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "4126c0c7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "('Not found', 1)"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def binary_search(array,item):\n",
    "    # inputs\n",
    "    # function arguments: sorted array and item to search for\n",
    "    \n",
    "    # process\n",
    "    # divide the array and check at the mid point\n",
    "    low = 0\n",
    "    high = len(array) - 1\n",
    "    while low <= high:\n",
    "        mid = (low + high) // 2\n",
    "        if item == array[mid]:\n",
    "            return mid\n",
    "        else:\n",
    "            if item > array[mid]:\n",
    "                low = mid + 1\n",
    "            else:\n",
    "                high = mid - 1\n",
    "    return 'Not found'\n",
    "            \n",
    "binary_search([2,5,8,10],700),binary_search([23,28,66,101],28)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4e6ff87d",
   "metadata": {},
   "source": [
    "## Segregate Positive and Negative Numbers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "c181f0fb",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'segregated array = [-2, -3, -1, -11, 2, 4, 5, 6, 9]'"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def segregate_positive_negative(array):\n",
    "    # input\n",
    "    # array of positive and negative numbers in function arguments\n",
    "    \n",
    "    # process\n",
    "    # using merge sort \n",
    "    if len(array) > 1:\n",
    "        mid=len(array)//2\n",
    "        left_array=array[:mid]\n",
    "        righ_array=array[mid:]\n",
    "        segregate_positive_negative(left_array)\n",
    "        segregate_positive_negative(righ_array)\n",
    "        i=j=k=0\n",
    "        while i < len(left_array) and j < len(righ_array):\n",
    "            if left_array[i] < 0:\n",
    "                array[k]=left_array[i]\n",
    "                i+=1\n",
    "                k+=1\n",
    "            elif righ_array[j] < 0:\n",
    "                array[k]=righ_array[j]\n",
    "                j+=1\n",
    "                k+=1\n",
    "            else:\n",
    "                break\n",
    "        while i < len(left_array):\n",
    "            array[k]=left_array[i]\n",
    "            i+=1\n",
    "            k+=1\n",
    "        while j < len(righ_array):\n",
    "            array[k]=righ_array[j]\n",
    "            j+=1\n",
    "            k+=1\n",
    "                \n",
    "    return f'segregated array = {array}'\n",
    "\n",
    "segregate_positive_negative([2,4,-2,5,-3,6,9,-1,-11])\n",
    "            "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6753b4fd",
   "metadata": {},
   "source": [
    "## Greedy Algorithm- Activity Selection Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "51e85dd1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"selected activites = ['A', 'C', 'D', 'F']\""
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# class for activity[name,start time,end time]\n",
    "class Activity():\n",
    "    def __init__(self,name,start=0,end=0):\n",
    "        self.name=name\n",
    "        self.start=start\n",
    "        self.end=end\n",
    "A,B,C=Activity('A',9,11),Activity('B',10,11),Activity('C',11,12)\n",
    "D,E,F=Activity('D',12,14),Activity('E',13,15),Activity('F',15,16)\n",
    "all_activities=[A,B,C,D,E,F]\n",
    "\n",
    "def select_activities(activities):\n",
    "    selected=[activities[0].name]\n",
    "    for i in range(1,len(activities)):\n",
    "        if activities[i].start >= activities[i-1].end:\n",
    "            selected.append(activities[i].name)\n",
    "    \n",
    "    return f'selected activites = {selected}'\n",
    "\n",
    "select_activities(all_activities)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "38ebca30",
   "metadata": {},
   "source": [
    "## Greedy Algorithm - Sorted Characters Frequencies"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a651ae95",
   "metadata": {},
   "source": [
    "### ASCII-Characters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "6f93e6bf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['w', 1.0],\n",
       " ['r', 1.0],\n",
       " ['h', 1.0],\n",
       " ['e', 1.0],\n",
       " ['d', 1.0],\n",
       " [' ', 1.0],\n",
       " ['o', 2.0],\n",
       " ['l', 3.0]]"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import numpy as np\n",
    "def ASCIIMethod(string):\n",
    "    # ASCII encode all english characters and numbers and special characters in 128 code starting from 0 to 127\n",
    "    # start  empty array of same size\n",
    "    char_freq=np.zeros(127)\n",
    "    for i in string:\n",
    "        current_code=ord(i)  # covert the character to its code in ASCII\n",
    "        char_freq[current_code]+=1   # increase its value in the freq array\n",
    "    frequency={}    \n",
    "    for j in range(len(char_freq)):\n",
    "        if char_freq[j]>0:\n",
    "            frequency[chr(j)]=char_freq[j]\n",
    "    frequency_list=[[i,j] for i , j in frequency.items()]\n",
    "           \n",
    "    def merge_sort(array):\n",
    "        if len(array) > 1:\n",
    "            midpoint=len(array)//2\n",
    "            left_array=array[:midpoint]\n",
    "            right_array=array[midpoint:]\n",
    "            merge_sort(left_array)\n",
    "            merge_sort(right_array)\n",
    "            i=j=k=0\n",
    "            while i< len(left_array) and j < len(right_array):\n",
    "                if left_array[i][1]<right_array[j][1]:\n",
    "                    array[k]=left_array[i]\n",
    "                    i+=1\n",
    "                    k+=1\n",
    "                else:\n",
    "                    array[k]=right_array[j]\n",
    "                    j+=1\n",
    "                    k+=1\n",
    "            while i < len(left_array):\n",
    "                array[k]=left_array[i]\n",
    "                i+=1\n",
    "                k+=1\n",
    "            while j < len(right_array):\n",
    "                array[k]=right_array[j]\n",
    "                j+=1\n",
    "                k+=1\n",
    "        return array\n",
    "    return (merge_sort(frequency_list))\n",
    "           \n",
    "ASCIIMethod('hello world')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48421cd5",
   "metadata": {},
   "source": [
    "### UTF-8"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "69d1c172",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['d', 1],\n",
       " ['r', 1],\n",
       " ['w', 1],\n",
       " [' ', 1],\n",
       " ['e', 1],\n",
       " ['h', 1],\n",
       " ['o', 2],\n",
       " ['l', 3]]"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def word_count_sorted(string):\n",
    "    freq={}\n",
    "    for i in string:\n",
    "        if i not in freq.keys():\n",
    "            freq[i]=1\n",
    "        else:\n",
    "            freq[i]+=1\n",
    "        counted_list=[[i,j] for i,j in freq.items()]\n",
    "\n",
    "    def merge_sort(array):\n",
    "        if len(array) > 1:\n",
    "            midpoint=len(array)//2\n",
    "            left_array=array[:midpoint]\n",
    "            right_array=array[midpoint:]\n",
    "            merge_sort(left_array)\n",
    "            merge_sort(right_array)\n",
    "            i=j=k=0\n",
    "            while i< len(left_array) and j < len(right_array):\n",
    "                if left_array[i][1]<right_array[j][1]:\n",
    "                    array[k]=left_array[i]\n",
    "                    i+=1\n",
    "                    k+=1\n",
    "                else:\n",
    "                    array[k]=right_array[j]\n",
    "                    j+=1\n",
    "                    k+=1\n",
    "            while i < len(left_array):\n",
    "                array[k]=left_array[i]\n",
    "                i+=1\n",
    "                k+=1\n",
    "            while j < len(right_array):\n",
    "                array[k]=right_array[j]\n",
    "                j+=1\n",
    "                k+=1\n",
    "        return array\n",
    "    return merge_sort(counted_list)\n",
    "\n",
    "word_count_sorted('hello world')     "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0cebb47d",
   "metadata": {},
   "source": [
    "## Greedy Algorithm-Huffman Encoding"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "575aae43",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['n', '10'], ['t', '11'], ['e', '00'], ['i', '010'], ['r', '011']]"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from heapq import heapify, heappop,heappush\n",
    "def huffman_encoding(string):\n",
    "    counter={}\n",
    "    for i in string:\n",
    "        if i not in counter.keys():\n",
    "            counter[i]=1\n",
    "        else:\n",
    "            counter[i]+=1\n",
    "    minheap=[[freq,[data,'']] for data,freq in counter.items()]\n",
    "    heapify(minheap)\n",
    "    while len(minheap) > 1:\n",
    "        left_node=heappop(minheap)\n",
    "        right_node=heappop(minheap)\n",
    "        for data in left_node[1:]:\n",
    "            data[1]='0'+data[1]\n",
    "        for data in right_node[1:]:\n",
    "            data[1]='1'+data[1]\n",
    "        heappush(minheap,[left_node[0]+right_node[0]]+left_node[1:]+right_node[1:])\n",
    "        huffman_list = right_node[1:] + left_node[1:]\n",
    "    return huffman_list\n",
    "huffman_encoding('internet')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6947bd4e",
   "metadata": {},
   "source": [
    "## Greedy Algorithm- Fractional knapsack Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "89dab80a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['b', 2, 9, 4.5],\n",
       " ['a', 1, 4, 4.0],\n",
       " ['d', 4, 11, 2.75],\n",
       " ['e', 3, 6, 2.0],\n",
       " ['c', 2, 2.4, 1.2]]"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "names=['a','b','c','d','e','f']\n",
    "weights=[1,2,10,4,3,5]\n",
    "values=[4,9,12,11,6,5]\n",
    "ratios=[i/j for i,j in zip(values,weights)]\n",
    "data=[[a,b,c,d] for a,b,c,d in zip(names,weights,values,ratios)]\n",
    "data.sort(key=lambda x:x[3],reverse=True)\n",
    "def knapsac_fill(data,k):\n",
    "    curent_weight=0\n",
    "    avaliable_weight=k-curent_weight\n",
    "    knapsack=[]\n",
    "    while curent_weight < k:\n",
    "        for i in data:\n",
    "            if i[1]<= avaliable_weight:\n",
    "                knapsack.append(i)\n",
    "                curent_weight+=i[1]\n",
    "                avaliable_weight-=i[1]\n",
    "            else:\n",
    "                i[1]=avaliable_weight\n",
    "                i[2]=avaliable_weight * i[3]\n",
    "                knapsack.append(i)\n",
    "                curent_weight+=i[1]\n",
    "                avaliable_weight-=i[1]\n",
    "                break\n",
    "    return knapsack\n",
    "\n",
    "knapsac_fill(data,12)                "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "818cc1d3",
   "metadata": {},
   "source": [
    "## Dynamic Programming-Stagecoach Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "a781bfa5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "optimum route is: ['A', 'C', 'E', 'H', 'J']\n",
      "cost :  11\n"
     ]
    }
   ],
   "source": [
    "labels=list(map(chr,range(ord('A'),ord('J')+1)))\n",
    "A=[['B','C','D'],[2,4,3]]\n",
    "B=[['E','F','G'],[7,4,6]]\n",
    "C=[['E','F','G'],[3,2,4]]\n",
    "D=[['E','F','G'],[4,1,5]]\n",
    "E=[['H','I'],[1,4]]\n",
    "F=[['H','I'],[6,3]]\n",
    "G=[['H','I'],[3,3]]\n",
    "H=[['J'],[3]]  \n",
    "I=[['J'],[4]] \n",
    "all_routes=[\n",
    "           [0,A[1][0],A[1][1],A[1][2],0,0,0,0,0,0],\n",
    "            [0,0,0,0,B[1][0],B[1][1],B[1][2],0,0,0],\n",
    "            [0,0,0,0,C[1][0],C[1][1],C[1][2],0,0,0],\n",
    "            [0,0,0,0,D[1][0],D[1][1],D[1][2],0,0,0],\n",
    "            [0,0,0,0,0,0,0,E[1][0],E[1][1],0],\n",
    "            [0,0,0,0,0,0,0,F[1][0],F[1][1],0],\n",
    "            [0,0,0,0,0,0,0,G[1][0],G[1][1],0],\n",
    "            [0,0,0,0,0,0,0,0,0,H[1][0]],\n",
    "            [0,0,0,0,0,0,0,0,0,I[1][0]],\n",
    "             [0,0,0,0,0,0,0,0,0,0]]\n",
    "def find_min_route(routes):\n",
    "    \n",
    "    minimum_route=routes[-1]\n",
    "    minimum_route[-1]={'from':'','to':'','cost':0}\n",
    "    max_num=float('inf')\n",
    "    for i in range(len(routes)-2,-1,-1):\n",
    "        minimum_route[i]={'from':labels[i],'to':labels[i+1],'cost':max_num}\n",
    "        for j in range(i+1,len(routes)):\n",
    "            if routes[i][j]==0:\n",
    "                continue\n",
    "            newcost=routes[i][j]+minimum_route[j]['cost']\n",
    "            if newcost< minimum_route[i]['cost']:\n",
    "                minimum_route[i]['to']=labels[j]\n",
    "                minimum_route[i]['cost']=newcost\n",
    "            \n",
    "    optimum_route=['A']\n",
    "    for i in minimum_route:\n",
    "        if i['from']=='A':\n",
    "            optimum_route.append(i['to'])\n",
    "            x=i['to']\n",
    "        else:\n",
    "            if i['from']==x:\n",
    "                optimum_route.append(i['to'])\n",
    "                x=i['to']\n",
    "    print(f'optimum route is: {optimum_route}')\n",
    "    print('cost : ',minimum_route[0]['cost'])\n",
    "    \n",
    "    \n",
    "find_min_route(all_routes)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a75ce721",
   "metadata": {},
   "source": [
    "## Dynamic Programming-Longest Common Subsequence Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "b5535134",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n",
      " [0. 0. 0. 0. 0. 1. 1. 1. 1. 1. 1.]\n",
      " [0. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]\n",
      " [0. 1. 2. 2. 2. 2. 2. 2. 2. 2. 2.]\n",
      " [0. 1. 2. 3. 3. 3. 3. 3. 3. 3. 3.]\n",
      " [0. 1. 2. 3. 3. 4. 4. 4. 4. 4. 4.]\n",
      " [0. 1. 2. 3. 3. 4. 4. 4. 4. 4. 5.]]\n",
      "longest common subsequent string is :  helod\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "def Longest_common_subsequence(string1,string2):\n",
    "    table=np.zeros((len(string2)+1,len(string1)+1))\n",
    "    for i in range(1,len(string2)+1):\n",
    "        for j in range(1,len(string1)+1):\n",
    "            if string2[i-1]!=string1[j-1]:\n",
    "                table[i,j]=max(table[i-1,j],table[i,j-1])\n",
    "            else:\n",
    "                table[i,j]=1+table[i-1,j-1]\n",
    "    print(table)\n",
    "    i=len(string2)\n",
    "    j=len(string1)\n",
    "    long_string=''\n",
    "    while i > 0 and j > 0:\n",
    "        if table[i,j]>table[i,j-1]:\n",
    "            if table[i,j]==table[i-1,j]:\n",
    "                i-=1\n",
    "            else:\n",
    "                long_string=string2[i-1]+long_string\n",
    "                i-=1\n",
    "                j-=1\n",
    "        else:\n",
    "            j-=1\n",
    "    print('longest common subsequent string is : ',long_string)\n",
    "    \n",
    "Longest_common_subsequence('helloworld','ohelod')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c0461da0",
   "metadata": {},
   "source": [
    "## Dynamic Programming-0/1 Knapsack Problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "a2526e32",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  item weight profit\n",
      "0    A      1      4\n",
      "1    B      3      9\n",
      "2    C      5     12\n",
      "3    D      4     11\n",
      "[[ 0.  0.  0.  0.  0.  0.  0.  0.  0.]\n",
      " [ 0.  4.  4.  4.  4.  4.  4.  4.  4.]\n",
      " [ 0.  4.  4.  9. 13. 13. 13. 13. 13.]\n",
      " [ 0.  4.  4.  9. 13. 13. 16. 16. 21.]\n",
      " [ 0.  4.  4.  9. 13. 15. 16. 20. 24.]]\n",
      "items selected: ['D', 'B', 'A']\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "weights=np.array([1,3,5,4])\n",
    "profits=np.array([4,9,12,11])\n",
    "items=['A','B','C','D']\n",
    "data1=pd.DataFrame([items,weights,profits],index=['item','weight','profit'])\n",
    "data1=data1.T\n",
    "print(data1)\n",
    "def knapsac_all_or_none(data,capacity):\n",
    "    table=np.zeros((len(data)+1,capacity+1))\n",
    "    for i in range(len(data)):\n",
    "        for j in range(1,capacity+1):\n",
    "            if data['weight'][i]<= j:\n",
    "                table[i+1,j]=max(table[i,j],(data['profit'][i]+table[i,j-data['weight'][i]]))\n",
    "            else:\n",
    "                table[i+1,j]=table[i,j]\n",
    "    print(table)\n",
    "    i=len(data)-1\n",
    "    j=capacity\n",
    "    remain=capacity\n",
    "    soln=[]\n",
    "    while remain > 0 :\n",
    "        if table[i+1,j]>table[i][j]:\n",
    "            soln.append(data['item'][i])\n",
    "            remain=remain-data['weight'][i]\n",
    "            i-=1\n",
    "            j=remain\n",
    "        else:\n",
    "            i-=1\n",
    "    print(f'items selected: {soln}')\n",
    "knapsac_all_or_none(data1,8)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eebbd6cb",
   "metadata": {},
   "source": [
    "## Graph-Prim's Minimum Spanning Tree Algorithm\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "98c48241",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "     1    2    3    4    5    6\n",
      "1  0.0  6.7  5.2  2.8  5.6  3.6\n",
      "2  6.7  0.0  5.7  7.3  5.1  3.2\n",
      "3  5.2  5.7  0.0  3.4  8.5  4.0\n",
      "4  2.8  7.3  3.4  0.0  8.0  4.4\n",
      "5  5.6  5.1  8.5  8.0  0.0  5.6\n",
      "6  3.6  3.2  4.0  4.4  4.6  0.0\n",
      "========================\n",
      "1 - 4 : 2.8\n",
      "4 - 3 : 3.4\n",
      "1 - 6 : 3.6\n",
      "6 - 2 : 3.2\n",
      "6 - 5 : 4.6\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "labels=np.arange(1,7)\n",
    "tree=[[0,6.7,5.2,2.8,5.6,3.6],\n",
    "           [6.7,0,5.7,7.3,5.1,3.2],\n",
    "           [5.2,5.7,0,3.4,8.5,4],\n",
    "           [2.8,7.3,3.4,0,8,4.4],\n",
    "           [5.6,5.1,8.5,8,0,5.6],\n",
    "           [3.6,3.2,4,4.4,4.6,0]]\n",
    "tree=pd.DataFrame(tree,columns=labels,index=labels)\n",
    "print(tree)\n",
    "print('========================')\n",
    "def min_spanning_tree(graph):\n",
    "    selected_nodes=np.zeros(6)\n",
    "    selected_nodes[0]=1\n",
    "    edges=0\n",
    "    while edges < len(graph)-1:\n",
    "        minimum=float('inf')\n",
    "        from_node=0\n",
    "        to_node=0\n",
    "        for i in range(len(graph)):\n",
    "            if selected_nodes[i]==1:\n",
    "                for j in range(len(graph)):\n",
    "                    if selected_nodes[j]==0 and graph.iloc[i,j]:\n",
    "                        if minimum > graph.iloc[i,j]:\n",
    "                            minimum=graph.iloc[i,j]\n",
    "                            from_node=i\n",
    "                            to_node=j\n",
    "        print(from_node+1,'-',to_node+1,':',minimum)\n",
    "        selected_nodes[to_node]=1\n",
    "        edges+=1\n",
    "        \n",
    "min_spanning_tree(tree)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3fd7fc58",
   "metadata": {},
   "source": [
    "## Graph-Breadth First Search Algorithm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "1013ee12",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "A - B\n",
      "A - C\n",
      "B - D\n",
      "B - E\n",
      "C - F\n",
      "F - H\n",
      "H - G\n",
      "H - I\n"
     ]
    }
   ],
   "source": [
    "from queue import Queue\n",
    "table={'A':['B','C'],\n",
    "       'B':['A','D','E'],\n",
    "       'C':['A','D','F'],\n",
    "       'D':['B','C','F'],\n",
    "       'E':['B','F'],\n",
    "       'F':['C','D','E','H'],\n",
    "       'H':['F','G','I'],\n",
    "       'G':['H','I'],\n",
    "       'I':['G','H']}\n",
    "def Breadth_First_search(graph):\n",
    "    queue=Queue()\n",
    "    visited=['A']\n",
    "    queue.put('A')\n",
    "    while queue.qsize() > 0 :\n",
    "        current_vetex=queue.get()\n",
    "        destintions=graph[current_vetex]\n",
    "        for i in range(len(destintions)):\n",
    "            if destintions[i] not in visited:\n",
    "                queue.put(destintions[i])\n",
    "                visited.append(destintions[i])\n",
    "                print(f'{current_vetex} - {destintions[i]}')\n",
    "Breadth_First_search(table)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5edb51a3",
   "metadata": {},
   "source": [
    "## Graph-Depth First Search Algorithm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "cddfea35",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "A-B\n",
      "B-D\n",
      "D-C\n",
      "C-F\n",
      "F-E\n",
      "F-H\n",
      "H-G\n",
      "G-I\n"
     ]
    }
   ],
   "source": [
    "class vertex:\n",
    "    def __init__(self,name,neighbors=None,visited=False):\n",
    "        self.name=name\n",
    "        self.neighbors=neighbors\n",
    "        self.visited=visited\n",
    "        \n",
    "A,B,C,D,E=vertex('A'),vertex('B'),vertex('C'),vertex('D'),vertex('E'),\n",
    "F,H,G,I,J=vertex('F'),vertex('H'),vertex('G'),vertex('I'),vertex('J')\n",
    "A.neighbors=[B,C] \n",
    "B.neighbors=[A,D,E]\n",
    "C.neighbors=[A,D,F]\n",
    "D.neighbors=[B,C,F]\n",
    "E.neighbors=[B,F]\n",
    "F.neighbors=[C,D,E,H]\n",
    "H.neighbors=[F,G,I]\n",
    "G.neighbors=[H,I]\n",
    "I.neighbors=[G,H]\n",
    "graph=[A,B,C,D,E,F,G,H,I,J]\n",
    "\n",
    "def Depth_First_search(vertex):\n",
    "    if not vertex.visited:\n",
    "        vertex.visited=True\n",
    "        for neighbor in vertex.neighbors:\n",
    "            if not neighbor.visited:\n",
    "                print(f'{vertex.name}-{neighbor.name}')\n",
    "                Depth_First_search(neighbor)\n",
    "Depth_First_search(graph[0])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72b0b08e",
   "metadata": {},
   "source": [
    "## Graph-Dijkstra's Shortest Path Algorithm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "id": "c6eea9dd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[None-A-0]\n",
      "[A-B-2]\n",
      "[A-C-4]\n",
      "[A-D-3]\n",
      "[C-E-3]\n",
      "[D-F-1]\n",
      "[C-G-4]\n",
      "[E-H-1]\n",
      "[F-I-3]\n",
      "[H-J-3]\n",
      "============================\n",
      "shortest-route is [ A-C-E-H-J ] cost=  11\n"
     ]
    }
   ],
   "source": [
    "class vertex:\n",
    "    def __init__(self,name,neighbors=None,best_source=None,source_length=float('inf'),total_length=0):\n",
    "        self.name=name\n",
    "        self.neighbors=neighbors\n",
    "        self.best_source=best_source\n",
    "        self.source_length=source_length\n",
    "        self.total_length=total_length\n",
    "        \n",
    "A,B,C,D,E=vertex('A'),vertex('B'),vertex('C'),vertex('D'),vertex('E'),\n",
    "F,H,G,I,J=vertex('F'),vertex('H'),vertex('G'),vertex('I'),vertex('J')\n",
    "A.neighbors=[[B,C,D],[2,4,3]]\n",
    "B.neighbors=[[E,F,G],[7,4,6]]\n",
    "C.neighbors=[[E,F,G],[3,2,4]]\n",
    "D.neighbors=[[E,F,G],[4,1,5]]\n",
    "E.neighbors=[[H,I],[1,4]]\n",
    "F.neighbors=[[H,I],[6,3]]\n",
    "G.neighbors=[[H,I],[3,3]]\n",
    "H.neighbors=[[J],[3]]\n",
    "I.neighbors=[[J],[4]]\n",
    "J.neighbors=[[],[]]\n",
    "A.source_length=0\n",
    "graph=[A,B,C,D,E,F,G,H,I,J]\n",
    "\n",
    "def Dijkstras_Shortest_Path(graph):\n",
    "    for i in graph:\n",
    "        for j in graph:\n",
    "            if i in j.neighbors[0]:\n",
    "                if j.neighbors[1][j.neighbors[0].index(i)]<i.source_length:\n",
    "                    i.source_length=j.neighbors[1][j.neighbors[0].index(i)]\n",
    "                    i.best_source=j.name\n",
    "                    i.total_length=i.source_length+j.total_length\n",
    "    for vertex in graph:\n",
    "        print(f'[{vertex.best_source}-{vertex.name}-{vertex.source_length}]')\n",
    "    route=graph[-1].name\n",
    "    i=len(graph)-1\n",
    "    while route[0] != graph[0].name:\n",
    "        for k in graph:\n",
    "            if k.name == graph[i].best_source:\n",
    "                route=k.name+'-'+route\n",
    "                i=graph.index(k)       \n",
    "    print('============================')\n",
    "    print('shortest-route is [',route,']'' cost= ',graph[-1].total_length)\n",
    "Dijkstras_Shortest_Path(graph)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
